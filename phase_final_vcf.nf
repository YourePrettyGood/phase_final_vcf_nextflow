#!/usr/bin/env nextflow
/* Pipeline for phasing per-chromosome jointly genotyped VCFs (filtered)    *
 * Core steps:                                                              *
 *  Unphase input genotypes and split by modern sample (and index each) ->  *
 *  Single-sample phasing with WhatsHap using BQSR BAMs ->                  *
 *  Merge single-sample phased VCFs into joint VCF (minus arc+PanTro) ->    *
 *  Population-level phasing with ShapeIt4 including WhatsHap phase info    */

//Default paths, globs, and regexes:
//Glob for the per-individual BAMs:
params.bam_glob = "${projectDir}/BAMs/*_MD_IR_recal.bam"
//Regex for parsing the sample ID out of the BAM filename:
params.bam_regex = ~/^(.+)_MD_IR_recal$/
//Glob for the joint VCFs:
params.vcf_glob = "${projectDir}/VCFs/*.vcf.gz"
//Regex for parsing the chromosome out of the VCF filename:
params.vcf_regex = ~/^.+_chr(\p{Alnum}+)$/

//Reference-related parameters for the pipeline:
params.ref_prefix = "/gpfs/gibbs/pi/tucci/pfr8/refs"
params.ref = "${params.ref_prefix}/1kGP/hs37d5/hs37d5.fa"
//X chromosome ID:
params.sex_chrom = "X"
//File of sample sexes:
params.sex_metadata = ""

//Set up the channels of BAMs and their indices:
//This variable is just used to allow merging to occur asynchronously for the chromosomes, rather than waiting for all whatshap jobs to finish:
//TODO: Cross-check this value against the number of VCFs from the split, and error if there's a mismatch as this indicates sample mismatch(es)
//      in the VCF or BAMs provided.
num_samples = file(params.bam_glob, checkIfExists: true).size()
println "Found ${num_samples} BAMs in the input directory"
Channel
   .fromPath(params.bam_glob, checkIfExists: true)
   .ifEmpty { error "Unable to find BAMs matching glob: ${params.bam_glob}" }
   .map { bam -> return [(bam.getSimpleName() =~ params.bam_regex)[0][1], bam] }
   .tap { bams }
   .subscribe { println "Added ${it[0]} (${it[1]}) to bams channel" }
Channel
   .fromPath(params.bam_glob+".bai", checkIfExists: true)
   .ifEmpty { error "Unable to find BAM indices matching glob: ${params.bam_glob}.bai" }
   .map { bai -> return [(bai.getSimpleName() =~ params.bam_regex)[0][1], bai] }
   .tap { bais }
   .subscribe { println "Added ${it[0]} (${it[1]}) to bais channel" }

//Set up the channels of input chromosomal VCFs and their indices:
Channel
   .fromPath(params.vcf_glob, checkIfExists: true)
   .ifEmpty { error "Unable to find VCFs matching glob: ${params.vcf_glob}" }
   .map { vcf -> return [(vcf.getSimpleName() =~ params.vcf_regex)[0][1], vcf] }
   .tap { vcfs }
   .subscribe { println "Added chr${it[0]} VCF (${it[1]}) to vcfs channel" }
Channel
   .fromPath(params.vcf_glob+".tbi", checkIfExists: true)
   .ifEmpty { error "Unable to find VCF indices matching glob: ${params.vcf_glob}.tbi" }
   .map { tbi -> return [(tbi.getSimpleName() =~ params.vcf_regex)[0][1], tbi] }
   .tap { tbis }
   .subscribe { println "Added chr${it[0]} VCF index (${it[1]}) to tbis channel" }

//Set up the file channels for the ref and its various index components:
//Inspired by the IARC alignment-nf pipeline
//fai is generated by samtools faidx, and dict is generated by Picard and used by GATK
ref = file(params.ref, checkIfExists: true)
ref_dict = file(params.ref.replaceFirst("[.]fn?a(sta)?([.]gz)?", ".dict"), checkIfExists: true)
ref_fai = file(params.ref+'.fai', checkIfExists: true)
//Set up the file channel for the sex metadata:
sex_metadata = file(params.sex_metadata, checkIfExists: true)

//Set up the channel for the genetic map:
Channel
   .fromPath(params.genmap_glob, checkIfExists: true)
   .ifEmpty { error "Unable to find genetic map files matching glob: ${params.genmap_glob}" }
   .map { genmap -> return [(genmap.getSimpleName() =~ params.genmap_regex)[0][1], genmap] }
   .tap { genmaps }
   .subscribe { println "Added chr${it[0]} genetic map (${it[1]}) to genmaps channel" }

//Default parameter values:
//Regexes for parsing metadata from intermediate filenames:
//params.persample_vcf_regex = ~/^chr(\p{Alnum}+)_([a-zA-Z0-9_-]+)_unphased/
//ShapeIt4 parameters:
//PRNG seed for reproducibility -- default is "15052011", though note that a run will only be reproducible if the number of threads is 1
params.prng_seed = '42'
//"Use phase sets in input files assuming an error rate of [FLOAT]" -- default is NA, but recommended to set to 0.0001
params.ps_errorrate = '0.0001'
//"iteration scheme for the MCMC" -- default is 5b,1p,1b,1p,1b,1p,5m, but 10b,1p,1b,1p,1b,1p,1b,1p,10m is suggested for greater accuracy if runtime isn't constrained
params.mcmc_scheme = '10b,1p,1b,1p,1b,1p,1b,1p,10m'
//"Depth of PBWT indexes to condition on" -- default is 4, but 8 is suggested for greater accuracy if runtime isn't constrained
params.pbwt_depth = '8'
//Default to not overwrite the more accurate ShapeIt4 parameters:
params.faster_shapeit = 0
if (params.faster_shapeit > 0) {
   params.mcmc_scheme = '5b,1p,1b,1p,1b,1p,5m'
   params.pbwt_depth = '4'
}

//Defaults for cpus, memory, and time for each process:
//Unphase, and split
params.unphase_split_cpus = 1
params.unphase_split_mem = 8
params.unphase_split_timeout = '24h'
//Whatshap per-sample per-chromosome phasing
params.whatshap_cpus = 1
params.whatshap_mem = 4
params.whatshap_timeout = '1h'
//Re-merge per-sample per-chromosome VCFs into per-chromosome VCFs
params.merge_cpus = 1
params.merge_mem = 1
params.merge_timeout = '24h'
//ShapeIt4 population phasing
params.shapeit_cpus = 1
params.shapeit_mem = 64
params.shapeit_timeout = '24h'
//Whatshap phasing stats
params.phasing_stats_cpus = 1
params.phasing_stats_mem = 4
params.phasing_stats_timeout = '24h'

process unphase_and_split {
   tag "${chr}"

   cpus params.unphase_split_cpus
   memory { params.unphase_split_mem.plus(task.attempt.minus(1).multiply(4))+' GB' }
   time { task.attempt == 2 ? '48h' : params.unphase_split_timeout }
   errorStrategy { task.exitStatus in 134..140 ? 'retry' : 'terminate' }
   maxRetries 1

   publishDir path: "${params.output_dir}/logs", mode: 'copy', pattern: '*.std{err,out}'

   input:
   tuple val(chr), path(vcf), path(tbi) from vcfs.join(tbis, by: 0, failOnMismatch: true)

   output:
   tuple path("bcftools_query_listsamples_chr${chr}.stderr"), path("whatshap_unphase_chr${chr}.stderr"), path("bcftools_split_chr${chr}.stderr"), path("bcftools_split_chr${chr}.stdout") into unphase_split_logs
   path("chr${chr}_*_unphased.vcf.gz") into unphased_persample_vcfs mode flatten
   path("chr${chr}_*_unphased.vcf.gz.tbi") into unphased_persample_tbis mode flatten

   shell:
   '''
   module load !{params.mod_bcftools}
   module load !{params.mod_htslib}
   module load !{params.mod_miniconda}
   #Load the conda environment for whatshap:
   conda activate whatshap
   #Set up the per-sample per-chromosome VCFs for whatshap:
   #First we need a sample map TSV:
   bcftools query -l !{vcf} 2> bcftools_query_listsamples_chr!{chr}.stderr | \
      !{projectDir}/samples_to_map_noArcPanTro.awk -v "chrom=!{chr}" > sample_VCF_map.tsv
   #Now do the removal of phasing from GATK and splitting by sample:
   #We force the ploidy of all samples for the X to be 2 for phasing.
   #Also, whatshap unphase errors out if not all diploid genotypes,
   # but doesn't give non-zero exit code, so let's bypass that issue.
   if [[ "!{chr}" == "!{params.sex_chrom}" ]]; then
      bcftools +fixploidy !{vcf} -- -t GT -f 2 2> bcftools_fixploidy_chr!{chr}.stderr | \
         whatshap unphase - 2> whatshap_unphase_chr!{chr}.stderr | \
         bcftools +split -S sample_VCF_map.tsv -Oz -o . 2> bcftools_split_chr!{chr}.stderr > bcftools_split_chr!{chr}.stdout
   else
      whatshap unphase !{vcf} 2> whatshap_unphase_chr!{chr}.stderr | \
         bcftools +split -S sample_VCF_map.tsv -Oz -o . 2> bcftools_split_chr!{chr}.stderr > bcftools_split_chr!{chr}.stdout
   fi
   #Remember to index the split VCFs:
   for i in chr*_unphased.vcf.gz;
   do
      tabix -f ${i};
   done
   '''
}

process whatshap {
   tag "chr${chr} ${id}"

   cpus params.whatshap_cpus
   memory { params.whatshap_mem.plus(task.attempt.minus(1).multiply(16))+' GB' }
   time { task.attempt == 2 ? '24h' : params.whatshap_timeout }
   errorStrategy { task.exitStatus in 134..140 ? 'retry' : 'terminate' }
   maxRetries 1

   publishDir path: "${params.output_dir}/logs", mode: 'copy', pattern: '*.std{err,out}'

   input:
   tuple val(id), val(chr), path("chr${chr}_${id}_unphased.vcf.gz"), path("chr${chr}_${id}_unphased.vcf.gz.tbi"), path(bam), path(bai) from unphased_persample_vcfs
      .flatten()
      .map({ vcf -> [(vcf.getSimpleName() =~ ~/^chr(\p{Alnum}+)_([a-zA-Z0-9_-]+)_unphased/)[0][2], (vcf.getSimpleName() =~ ~/^chr(\p{Alnum}+)_([a-zA-Z0-9_-]+)_unphased/)[0][1], vcf] })
      .join(unphased_persample_tbis
         .flatten()
         .map({ tbi -> [(tbi.getSimpleName() =~ ~/^chr(\p{Alnum}+)_([a-zA-Z0-9_-]+)_unphased/)[0][2], (tbi.getSimpleName() =~ ~/^chr(\p{Alnum}+)_([a-zA-Z0-9_-]+)_unphased/)[0][1], tbi] }), by: [0,1], failOnMismatch: true)
      .combine(bams
         .join(bais, by: 0, failOnMismatch: true), by: 0)
   path ref
   path ref_fai

   output:
   tuple path("whatshap_phase_chr${chr}_${id}.stderr"), path("whatshap_phase_chr${chr}_${id}.stdout") into whatshap_logs
   tuple val(chr), path("chr${chr}_${id}_phased.vcf.gz") into phased_persample_vcfs
   tuple val(chr), path("chr${chr}_${id}_phased.vcf.gz.tbi") into phased_persample_tbis

   shell:
   whatshap_params = '--indels'
   '''
   module load !{params.mod_htslib}
   module load !{params.mod_miniconda}
   conda activate whatshap
   whatshap phase -r !{ref} --chromosome !{chr} !{whatshap_params} -o chr!{chr}_!{id}_phased.vcf.gz chr!{chr}_!{id}_unphased.vcf.gz !{bam} 2> whatshap_phase_chr!{chr}_!{id}.stderr > whatshap_phase_chr!{chr}_!{id}.stdout
   tabix -f chr!{chr}_!{id}_phased.vcf.gz
   '''
}

process merge {
   tag "chr${chr}"

   cpus params.merge_cpus
   memory { params.merge_mem.plus(task.attempt.minus(1).multiply(16))+' GB' }
   time { task.attempt == 2 ? '48h' : params.merge_timeout }
   errorStrategy { task.exitStatus in 134..140 ? 'retry' : 'terminate' }
   maxRetries 1

   publishDir path: "${params.output_dir}/logs", mode: 'copy', pattern: '*.std{err,out}'

   input:
   tuple val(chr), path(input_paths) from phased_persample_vcfs
      .collectFile() { [ it[0]+".txt", it[1].getSimpleName()+'\t'+it[1].getName()+'\t'+it[1]+'\n' ] }
      .map({ [it.getSimpleName(), it] })
//   path("whatshap_vcf_paths.tsv") phased_persample_vcfs.collectFile() { [ "whatshap_vcf_paths.tsv", it.getSimpleName()+'\t'+it.getName()+'\t'+it+'\n' ] }
//   path("whatshap_tbi_paths.tsv") phased_persample_tbis.collectFile() { [ "whatshap_tbi_paths.tsv", it.getSimpleName()+'\t'+it.getName()+'\t'+it+'\n' ] }
//   tuple val(chr), path("*") from phased_persample_vcfs.groupTuple(sort: true, size: num_samples)
//   tuple val(tbi_chr), path("*") from phased_persample_tbis.groupTuple(sort: true, size: num_samples)

   output:
   tuple path("bcftools_merge_persample_chr${chr}.stderr"), path("bcftools_merge_persample_chr${chr}.stdout") into merge_logs
   tuple val(chr), path("chr${chr}_persample_phased.vcf.gz"), path("chr${chr}_persample_phased.vcf.gz.tbi") into whatshap_merged_vcfs
   tuple val(chr), val("whatshap"), path("chr${chr}_persample_phased.vcf.gz"), path("chr${chr}_persample_phased.vcf.gz.tbi") into whatshap_phased_vcfs

   shell:
   '''
   module load !{params.mod_bcftools}
   module load !{params.mod_htslib}
   #Symlink the input files, since SLURM dislikes the big SBATCH files that
   # Nextflow creates when there are hundreds/thousands of inputs:
   while read -a a;
      do
      ln -s ${a[2]} ${a[1]};
      ln -s ${a[2]}.tbi ${a[1]}.tbi;
   done < !{input_paths}
   #Re-join the per-sample VCFs into one phased merged VCF (without archaics/PanTro):
   #Generate the sorted list of VCFs:
   ls chr!{chr}_*_phased.vcf.gz | \
      sort -k1,1V > phased_VCF_list.tsv
   #Merge the VCFs in order:
   bcftools merge -m all -l phased_VCF_list.tsv -Oz -o chr!{chr}_persample_phased.vcf.gz 2> bcftools_merge_persample_chr!{chr}.stderr > bcftools_merge_persample_chr!{chr}.stdout
   tabix -f chr!{chr}_persample_phased.vcf.gz
   '''
}

process shapeit {
   tag "chr${chr}"

   cpus params.shapeit_cpus
   memory { params.shapeit_mem.plus(task.attempt.minus(1).multiply(16))+' GB' }
   time { task.attempt == 2 ? '72h' : params.shapeit_timeout }
   errorStrategy { task.exitStatus in 134..140 ? 'retry' : 'terminate' }
   maxRetries 1

   publishDir path: "${params.output_dir}/logs", mode: 'copy', pattern: '*.{log,stderr,stdout}'
   publishDir path: "${params.output_dir}/phased_VCFs", mode: 'copy', pattern: '*_pop_phased.vcf.g{z,z.tbi}', saveAs: { params.final_prefix+it }

   input:
   tuple val(chr), path("chr${chr}_persample_phased.vcf.gz"), path("chr${chr}_persample_phased.vcf.gz.tbi"), path(genmap) from whatshap_merged_vcfs.join(genmaps, by: 0)

   output:
   tuple path("shapeit4_pop_phasing_chr${chr}.log"), path("shapeit4_pop_phasing_chr${chr}.stderr"), path("shapeit4_pop_phasing_chr${chr}.stdout") into shapeit_logs
   tuple val(chr), val("shapeit4"), path("chr${chr}_pop_phased.vcf.gz"), path("chr${chr}_pop_phased.vcf.gz.tbi") into shapeit_phased_vcfs

   shell:
   shapeit_params = """--sequencing --use-PS ${params.ps_errorrate} --seed ${params.prng_seed} \
                       --mcmc-iterations ${params.mcmc_scheme} --pbwt-depth ${params.pbwt_depth}"""
   '''
   module load !{params.mod_bcftools}
   module load !{params.mod_htslib}
   module load !{params.mod_miniconda}
   conda activate shapeit4
   if [[ "!{chr}" == "!{params.sex_chrom}" ]]; then
      shapeit4 -M !{genmap} -R !{chr} !{shapeit_params} --thread !{task.cpus} -I chr!{chr}_persample_phased.vcf.gz -O chr!{chr}_pop_phased_forceddiploid.vcf.gz --log shapeit4_pop_phasing_chr!{chr}.log 2> shapeit4_pop_phasing_chr!{chr}.stderr > shapeit4_pop_phasing_chr!{chr}.stdout
      bcftools +fixploidy -Oz -o chr!{chr}_pop_phased.vcf.gz chr!{chr}_pop_phased_forceddiploid.vcf.gz -- -s !{sex_metadata} -t GT 2> bcftools_fixploidy_undo_chr!{chr}.stderr > bcftools_fixploidy_undo_chr!{chr}.stdout
   else
      shapeit4 -M !{genmap} -R !{chr} !{shapeit_params} --thread !{task.cpus} -I chr!{chr}_persample_phased.vcf.gz -O chr!{chr}_pop_phased.vcf.gz --log shapeit4_pop_phasing_chr!{chr}.log 2> shapeit4_pop_phasing_chr!{chr}.stderr > shapeit4_pop_phasing_chr!{chr}.stdout
   fi
   tabix -f chr!{chr}_pop_phased.vcf.gz
   '''
}

process phasing_stats {
   tag "chr${chr}"

   cpus params.phasing_stats_cpus
   memory { params.phasing_stats_mem.plus(task.attempt.minus(1).multiply(4))+' GB' }
   time { task.attempt == 2 ? '48h' : params.phasing_stats_timeout }
   errorStrategy { task.exitStatus in 134..140 ? 'retry' : 'terminate' }
   maxRetries 1

   publishDir path: "${params.output_dir}/logs", mode: 'copy', pattern: '*.std{err,out}'
   publishDir path: "${params.output_dir}/phasing", mode: 'copy', pattern: '*.{tsv,gtf}'
   publishDir path: "${params.output_dir}/phasing", mode: 'copy', pattern: 'bcftools_trioswitchrate_*.stdout'

   input:
   tuple val(chr), val(phasesrc), path(vcf), path(tbi) from whatshap_phased_vcfs.mix(shapeit_phased_vcfs)

   output:
   tuple path("whatshap_stats_chr${chr}_${phasesrc}.stderr"), path("whatshap_stats_chr${chr}_${phasesrc}.stdout"), path("bcftools_trioswitchrate_chr${chr}_${phasesrc}.stderr"), path("bcftools_trioswitchrate_chr${chr}_${phasesrc}.stdout") into whatshap_stats_logs
   tuple path("${params.final_prefix}_chr${chr}_${phasesrc}_phasing_stats.tsv"), path("${params.final_prefix}_chr${chr}_${phasesrc}_haplotype_blocks.gtf"), path("bcftools_trioswitchrate_chr${chr}_${phasesrc}.stdout") into whatshap_stats_output

   shell:
   '''
   module load !{params.mod_bcftools}
   module load !{params.mod_miniconda}
   conda activate whatshap
   whatshap stats --tsv=!{params.final_prefix}_chr!{chr}_!{phasesrc}_phasing_stats.tsv --gtf=!{params.final_prefix}_chr!{chr}_!{phasesrc}_haplotype_blocks.gtf !{vcf} 2> whatshap_stats_chr!{chr}_!{phasesrc}.stderr > whatshap_stats_chr!{chr}_!{phasesrc}.stdout
   bcftools +trio-switch-rate !{vcf} -- -p !{trioped} 2> bcftools_trioswitchrate_chr!{chr}_!{phasesrc}.stderr > bcftools_trioswitchrate_chr!{chr}_!{phasesrc}.stdout
   '''
}
