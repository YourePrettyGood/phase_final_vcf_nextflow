#!/usr/bin/env nextflow
/* Pipeline for phasing per-chromosome jointly genotyped VCFs (filtered)    *
 * Core steps:                                                              *
 *  Extract only sites PASSing filters ->                                   *
 *  Unphase input genotypes and split by modern sample (and index each) ->  *
 *  Single-sample phasing with WhatsHap using BQSR BAMs ->                  *
 *  Merge single-sample phased VCFs into joint VCF (minus arc+PanTro) ->    *
 *  Population-level phasing with ShapeIt4 including WhatsHap phase info    */

//Default paths, globs, and regexes:
//Glob for the per-individual BAMs:
params.bam_glob = "${projectDir}/BAMs/*_MD_IR_recal.bam"
//Regex for parsing the sample ID out of the BAM filename:
params.bam_regex = ~/^(.+)_MD_IR_recal$/
//Glob for the joint VCFs:
params.vcf_glob = "${projectDir}/VCFs/*.vcf.gz"
//Regex for parsing the chromosome out of the VCF filename:
params.vcf_regex = ~/^.+_chr(\p{Alnum}+)$/

//Reference-related parameters for the pipeline:
params.ref_prefix = "/gpfs/gibbs/pi/tucci/pfr8/refs"
params.ref = "${params.ref_prefix}/1kGP/hs37d5/hs37d5.fa"

//Set up the channels of BAMs and their indices:
Channel
   .fromPath(params.bam_glob, checkIfExists: true)
   .ifEmpty { error "Unable to find BAMs matching glob: ${params.bam_glob}" }
   .map { bam -> return [(bam.getSimpleName() =~ params.bam_regex)[0][1], bam] }
   .tap { bams, bams_tocount }
   .subscribe { println "Added ${it[0]} (${it[1]}) to bams channel" }
Channel
   .fromPath(params.bam_glob+".bai", checkIfExists: true)
   .ifEmpty { error "Unable to find BAM indices matching glob: ${params.bam_glob}.bai" }
   .map { bai -> return [(bai.getSimpleName() =~ params.bam_regex)[0][1], bai] }
   .tap { bais }
   .subscribe { println "Added ${it[0]} (${it[1]}) to bais channel" }
//This variable is just used to allow merging to occur asynchronously for the chromosomes, rather than waiting for all whatshap jobs to finish:
//TODO: Cross-check this value against the number of VCFs from the split, and error if there's a mismatch (as this indicates sample mismatch(es)
//      in the VCF or BAMs provided.
num_samples = bam_tocount.count()

//Set up the channels of input chromosomal VCFs and their indices:
Channel
   .fromPath(params.vcf_glob, checkIfExists: true)
   .ifEmpty { error "Unable to find VCFs matching glob: ${params.vcf_glob}" }
   .map { vcf -> return [(vcf.getSimpleName() =~ params.vcf_regex)[0][1], vcf] }
   .tap { vcfs }
   .subscribe { println "Added chr${it[0]} VCF (${it[1]}) to vcfs channel" }
Channel
   .fromPath(params.vcf_glob+".tbi", checkIfExists: true)
   .ifEmpty { error "Unable to find VCF indices matching glob: ${params.vcf_glob}.tbi" }
   .map { tbi -> return [(tbi.getSimpleName() =~ params.vcf_regex)[0][1], tbi] }
   .tap { tbis }
   .subscribe { println "Added chr${it[0]} VCF index (${it[1]}) to tbis channel" }

//Set up the file channels for the ref and its various index components:
//Inspired by the IARC alignment-nf pipeline
//fai is generated by samtools faidx, and dict is generated by Picard and used by GATK
ref = file(params.ref, checkIfExists: true)
ref_dict = file(params.ref.replaceFirst("[.]fn?a(sta)?([.]gz)?", ".dict"), checkIfExists: true)
ref_fai = file(params.ref+'.fai', checkIfExists: true)

//Set up the channel for the genetic map:
Channel
   .fromPath(params.genmap_glob, checkIfExists: true)
   .ifEmpty { error "Unable to find genetic map files matching glob: ${params.genmap_glob}" }
   .map { genmap -> return [(genmap.getSimpleName() =~ params.genmap_regex)[0][1], genmap] }
   .tap { genmaps }
   .subscribe { println "Added chr${it[0]} genetic map (${it[1]}) to genmaps channel" }

//Default parameter values:
//Regexes for parsing metadata from intermediate filenames:
persample_vcf_regex = ~/^chr(\p{Alnum}+)_([a-zA-Z0-9_-]+)_unphased/
//ShapeIt4 parameters:
//PRNG seed for reproducibility -- default is "15052011", though note that a run will only be reproducible if the number of threads is 1
params.prng_seed = '42'
//"Use phase sets in input files assuming an error rate of [FLOAT]" -- default is NA, but recommended to set to 0.0001
ps_errorrate = '0.0001'
//"iteration scheme for the MCMC" -- default is 5b,1p,1b,1p,1b,1p,5m, but 10b,1p,1b,1p,1b,1p,1b,1p,10m is suggested for greater accuracy if runtime isn't constrained
mcmc_scheme = '10b,1p,1b,1p,1b,1p,1b,1p,10m'
//"Depth of PBWT indexes to condition on" -- default is 4, but 8 is suggested for greater accuracy if runtime isn't constrained
pbwt_depth = '8'
if (params.faster_shapeit) {
   mcmc_scheme = '5b,1p,1b,1p,1b,1p,5m'
   pbwt_depth = '4'
}

//Defaults for cpus, memory, and time for each process:
//Filter for PASS, unphase, and split
params.filter_split_cpus = 1
params.filter_split_mem = 8
params.filter_split_timeout = '24h'
//Whatshap per-sample per-chromosome phasing
params.whatshap_cpus = 1
params.whatshap_mem = 4
params.whatshap_timeout = '1h'
//Re-merge per-sample per-chromosome VCFs into per-chromosome VCFs
params.merge_cpus = 1
params.merge_mem = 1
params.merge_timeout = '24h'
//ShapeIt4 population phasing
params.shapeit_cpus = 1
params.shapeit_mem = 64
params.shapeit_timeout = '24h'
//Whatshap phasing stats
params.phasing_stats_cpus = 1
params.phasing_stats_mem = 4
params.phasing_stats_timeout = '24h'

process filter_and_split {
   tag "${chr}"

   cpus params.filter_split_cpus
   memory { params.filter_split_mem.plus(task.attempt.minus(1).multiply(4))+' GB' }
   time { task.attempt == 2 ? '48h' : params.filter_split_timeout }
   errorStrategy { task.exitStatus in 134..140 ? 'retry' : 'terminate' }
   maxRetries 1

   publishDir path: "${params.output_dir}/logs", mode: 'copy', pattern: '*.std{err,out}'

   input:
   tuple val(chr), path(vcf), path(tbi) from vcfs.join(tbis, by: 0, failOnMismatch: true)

   output:
   tuple path("bcftools_query_listsamples_chr${chr}.stderr"), path("bcftools_view_filterPASS_chr${chr}.stderr"), path("whatshap_unphase_chr${chr}.stderr"), path("bcftools_split_chr${chr}.stderr"), path("bcftools_split_chr${chr}.stdout") into filter_split_logs
   path("chr${chr}_*_unphased.vcf.gz") into unphased_persample_vcfs
   path("chr${chr}_*_unphased.vcf.gz.tbi") into unphased_persample_tbis

   shell:
   '''
   module load !{params.mod_bcftools}
   module load !{params.mod_htslib}
   module load !{params.mod_miniconda}
   conda activate whatshap
   #Set up the per-sample per-chromosome VCFs for whatshap:
   #First we need a sample map TSV:
   bcftools query -l !{vcf} 2> bcftools_query_listsamples_chr!{chr}.stderr | \
      awk -v "chrom=!{chr}" 'BEGIN{OFS="\t";}!/^Altai|Denisova|Vindija|Chagyrskaya|pan_troglodytes/{print $1, "-", "chr"chrom"_"$1"_unphased";}' > sample_VCF_map.tsv
   #Now do the filtering, removal of phasing from GATK, and splitting by sample:
   bcftools view -f PASS !{vcf} 2> bcftools_view_filterPASS_chr!{chr}.stderr | \
      whatshap unphase - 2> whatshap_unphase_chr!{chr}.stderr | \
      bcftools +split -S sample_VCF_map.tsv -Oz -o . 2> bcftools_split_chr!{chr}.stderr > bcftools_split_chr!{chr}.stdout
   #Remember to index the split VCFs:
   for i in chr*_unphased.vcf.gz;
   do
      tabix -f ${i};
   done
   '''
}

process whatshap {
   tag "chr${chr} ${id}"

   cpus params.whatshap_cpus
   memory { params.whatshap_mem.plus(1).plus(task.attempt.minus(1).multiply(16))+' GB' }
   time { task.attempt == 2 ? '24h' : params.whatshap_timeout }
   errorStrategy { task.exitStatus in 134..140 ? 'retry' : 'terminate' }
   maxRetries 1

   publishDir path: "${params.output_dir}/logs", mode: 'copy', pattern: '*.std{err,out}'

   input:
   tuple val(id), val(chr), path("chr${chr}_${id}_unphased.vcf.gz"), path("chr${chr}_${id}_unphased.vcf.gz.tbi"), path(bam), path(bai) from unphased_persample_vcfs.flatten().map({ vcf -> [(vcf.getSimpleName() =~ persample_vcf_regex)[0][2], (vcf.getSimpleName() =~ persample_vcf_regex)[0][1], vcf] }).join(unphased_persample_tbis.flatten().map({ tbi -> [(tbi.getSimpleName() =~ persample_vcf_regex)[0][2], (tbi.getSimpleName() =~ persample_vcf_regex)[0][1], tbi] }), by: [0,1], failOnMismatch: true).combine(bams.join(bais, by: 0, failOnMismatch: true), by: 0)
   path ref
   path ref_fai

   output:
   tuple path("whatshap_phase_chr${chr}_${id}.stderr"), path("whatshap_phase_chr${chr}_${id}.stdout") into whatshap_logs
   tuple val(chr), path("chr${chr}_${id}_phased.vcf.gz") into phased_persample_vcfs
   tuple val(chr), path("chr${chr}_${id}_phased.vcf.gz.tbi") into phased_persample_tbis

   shell:
   whatshap_params = '--indels'
   '''
   module load !{params.mod_htslib}
   module load !{params.mod_miniconda}
   conda activate whatshap
   whatshap phase -r !{ref} --chromosome !{chr} !{whatshap_params} -o chr!{chr}_!{id}_phased.vcf.gz chr!{chr}_!{id}_unphased.vcf.gz !{bam} 2> 
   tabix -f chr!{chr}_!{id}_phased.vcf.gz
   '''
}

process merge {
   tag "chr${chr}"

   cpus params.merge_cpus
   memory { params.merge_mem.plus(1).plus(task.attempt.minus(1).multiply(16))+' GB' }
   time { task.attempt == 2 ? '48h' : params.merge_timeout }
   errorStrategy { task.exitStatus in 134..140 ? 'retry' : 'terminate' }
   maxRetries 1

   publishDir path: "${params.output_dir}/logs", mode: 'copy', pattern: '*.std{err,out}'

   input:
   tuple val(chr), path("*") from phased_persample_vcfs.groupTuple(sort: true, size: num_samples)
   tuple val(tbi_chr), path("*") from phased_persample_tbis.groupTuple(sort: true, size: num_samples)

   output:
   tuple path("bcftools_merge_persample_chr${chr}.stderr"), path("bcftools_merge_persample_chr${chr}.stdout") into merge_logs
   tuple val(chr), path("chr${chr}_persample_phased.vcf.gz"), path("chr${chr}_persample_phased.vcf.gz.tbi") into whatshap_merged_vcfs,whatshap_phased_vcfs

   shell:
   '''
   module load !{params.mod_bcftools}
   module load !{params.mod_htslib}
   //Re-join the per-sample VCFs into one phased merged VCF (without archaics/PanTro):
   //Generate the sorted list of VCFs:
   find . -mindepth 1 -maxdepth 1 -type f -name "chr*_phased.vcf.gz" -print | \
      cut -f2 -d"/" | \
      sort -k1,1V > phased_VCF_list.tsv
   //Merge the VCFs in order:
   bcftools merge -m all -l phased_VCF_list.tsv -Oz -o chr!{chr}_persample_phased.vcf.gz 2> bcftools_merge_persample_chr!{chr}.stderr > bcftools_merge_persample_chr!{chr}.stdout
   tabix -f chr!{chr}_persample_phased.vcf.gz
   '''
}

process shapeit {
   tag "chr${chr}"

   cpus params.shapeit_cpus
   memory { params.shapeit_mem.plus(1).plus(task.attempt.minus(1).multiply(16))+' GB' }
   time { task.attempt == 2 ? '72h' : params.shapeit_timeout }
   errorStrategy { task.exitStatus in 134..140 ? 'retry' : 'terminate' }
   maxRetries 1

   publishDir path: "${params.output_dir}/logs", mode: 'copy', pattern: '*.{log,stderr,stdout}'
   publishDir path: "${params.output_dir}/phased_VCFs", mode: 'copy', pattern: '*_pop_phased.vcf.g{z,z.tbi}', saveAs: { ${params.final_prefix}+it }

   input:
   tuple val(chr), path("chr${chr}_persample_phased.vcf.gz"), path("chr${chr}_persample_phased.vcf.gz.tbi"), path(genmap) from whatshap_merged_vcfs.join(genmaps, by: 0)

   output:
   tuple path("shapeit4_pop_phasing_chr${chr}.log"), path("shapeit4_pop_phasing_chr${chr}.stderr"), path("shapeit4_pop_phasing_chr${chr}.stdout") into shapeit_logs
   tuple val(chr), path("chr${chr}_pop_phased.vcf.gz"), path("chr${chr}_pop_phased.vcf.gz.tbi") into shapeit_phased_vcfs

   shell:
   shapeit_params = "--sequencing --use-PS ${ps_errorrate} --seed ${params.prng_seed}"
   shapeit_params = "${shapeit_params} --mcmc-iterations ${mcmc_scheme} --pbwt-depth ${pbwt_depth}"
   '''
   module load !{params.mod_htslib}
   module load !{params.mod_miniconda}
   conda activate shapeit4
   shapeit4 -M !{genmap} -R !{chr} !{shapeit_params} --thread !{task.cpus} -I chr!{chr}_persample_phased.vcf.gz -o chr!{chr}_pop_phased.vcf.gz --log shapeit4_pop_phasing_chr!{chr}.log 2> shapeit4_pop_phasing_chr!{chr}.stderr > shapeit4_pop_phasing_chr!{chr}.stdout
   tabix -f chr!{chr}_pop_phased.vcf.gz
   '''
}

process phasing_stats {
   tag "chr${chr}"

   cpus params.phasing_stats_cpus
   memory { params.phasing_stats_mem.plus(1).plus(task.attempt.minus(1).multiply(4))+' GB' }
   time { task.attempt == 2 ? '48h' : params.phasing_stats_timeout }
   errorStrategy { task.exitStatus in 134..140 ? 'retry' : 'terminate' }
   maxRetries 1

   publishDir path: "${params.output_dir}/logs", mode: 'copy', pattern: '*.std{err,out}'
   publishDir path: "${params.output_dir}/phasing" mode: 'copy', pattern: '*.{tsv.gtf}'

   input:
   tuple val(chr), val(src), path(vcf) from whatshap_phased_vcfs.map({ [it[0], "whatshap", it[1]] }).mix(shapeit_phased_vcfs.map({ [it[0], "shapeit4", it[1]] }))

   output:
   tuple path("whatshap_stats_chr${chr}_${src}.stderr"), path("whatshap_stats_chr${chr}_${src}.stdout") into whatshap_stats_logs
   tuple path("${params.final_prefix}_chr${chr}_${src}_phasing_stats.tsv"), path("${params.final_prefix}_chr${chr}_${src}_haplotype_blocks.gtf") into whatshap_stats_output

   shell:
   '''
   module load !{params.mod_miniconda}
   conda activate whatshap
   whatshap stats --tsv=!{params.final_prefix}_chr!{chr}_!{src}_phasing_stats.tsv --gtf=!{params.final_prefix}_chr!{chr}_!{src}_haplotype_blocks.gtf !{vcf} 2> whatshap_stats_chr!{chr}_!{src}.stderr > whatshap_stats_chr!{chr}_!{src}.stdout
   '''
}
